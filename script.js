// Generated by CoffeeScript 1.7.1
(function() {
  var APP, Hexagon,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Hexagon = (function() {

    /*
       1 ____ 2
       /|\  /|\
     6/ | \/ | \3
      \ | /\ | /
      5\|/__\|/4
     */
    function Hexagon(x, y, size) {
      this.x = x;
      this.y = y;
      this.size = size;
    }

    Hexagon.prototype.verticiesData = function() {
      var colours, edgeLength, hexHeight, i, result, verticies, x, y, _i, _len, _ref;
      edgeLength = this.size;
      hexHeight = edgeLength / (Math.tan(Math.PI / 6));
      verticies = [[this.x - edgeLength / 2, this.y + hexHeight / 2], [this.x + edgeLength / 2, this.y + hexHeight / 2], [this.x + edgeLength, this.y], [this.x + edgeLength / 2, this.y - hexHeight / 2], [this.x - edgeLength / 2, this.y - hexHeight / 2], [this.x - edgeLength, this.y]];
      result = [];
      colours = [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0], [1, 0, 1], [0, 1, 1]];
      for (i = _i = 0, _len = verticies.length; _i < _len; i = ++_i) {
        _ref = verticies[i], x = _ref[0], y = _ref[1];
        result.push(x);
        result.push(y);
        result.push(colours[i][0]);
        result.push(colours[i][1]);
        result.push(colours[i][2]);
      }
      return result;
    };

    Hexagon.prototype.facesData = function(n) {
      var faces;
      faces = [1, 4, 2, 2, 4, 3, 1, 5, 4, 1, 6, 5];
      return faces.map(function(i) {
        return i - 1 + n;
      });
    };

    return Hexagon;

  })();

  window.APP = APP = new ((function() {
    function _Class() {
      this.start = __bind(this.start, this);
      this.draw = __bind(this.draw, this);
    }

    _Class.prototype.VERTEX = 2;

    _Class.prototype.FRAGMENT = 3;

    _Class.prototype.vertexShaderSource = "attribute vec2 position;\nattribute vec3 color;\n\nvarying vec3 vColor;\nvoid main(void) {\n  gl_Position = vec4(position, 0., 1.);\n  vColor=color;\n}";

    _Class.prototype.fragmentShaderSource = "precision mediump float;\n\nvarying vec3 vColor;\nvoid main(void) {\n  gl_FragColor = vec4(vColor, 1.);\n}";

    _Class.prototype.getShader = function(type, source) {
      var shader;
      shader = this.GL.createShader(type);
      this.GL.shaderSource(shader, source);
      this.GL.compileShader(shader);
      if (!this.GL.getShaderParameter(shader, this.GL.COMPILE_STATUS)) {
        alert("ERROR IN " + (type === this.GL.VERTEX_SHADER ? 'vertex' : 'fragment') + " SHADER : " + (this.GL.getShaderInfoLog(shader)));
        return false;
      }
      return shader;
    };

    _Class.prototype.initCanvas = function() {
      var canvas;
      canvas = document.getElementById("canvas");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      this.canvas = canvas;
      return true;
    };

    _Class.prototype.initGLContext = function() {
      this.GL = this.canvas.getContext("experimental-webgl", {
        antialias: true
      });
      return true;
    };

    _Class.prototype.initShaders = function() {
      var fragmentShader, shaderProgram, vertexShader;
      vertexShader = this.getShader(this.GL.VERTEX_SHADER, this.vertexShaderSource);
      fragmentShader = this.getShader(this.GL.FRAGMENT_SHADER, this.fragmentShaderSource);
      shaderProgram = this.GL.createProgram();
      this.GL.attachShader(shaderProgram, vertexShader);
      this.GL.attachShader(shaderProgram, fragmentShader);
      this.GL.linkProgram(shaderProgram);
      this.shaderProgram = shaderProgram;
      this._color = this.GL.getAttribLocation(shaderProgram, "color");
      this._position = this.GL.getAttribLocation(shaderProgram, "position");
      this.GL.enableVertexAttribArray(this._color);
      this.GL.enableVertexAttribArray(this._position);
      return true;
    };

    _Class.prototype.initTriangle = function() {
      var datum, facesData, hexagon, i, triangleFacesData, triangleVertexData, verticiesData, _i, _j, _k, _len, _len1, _len2, _ref;
      this.hexagons = [new Hexagon(0, 0, 0.5)];
      triangleVertexData = [];
      triangleFacesData = [];
      _ref = this.hexagons;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        hexagon = _ref[i];
        verticiesData = hexagon.verticiesData();
        for (_j = 0, _len1 = verticiesData.length; _j < _len1; _j++) {
          datum = verticiesData[_j];
          triangleVertexData.push(datum);
        }
        facesData = hexagon.facesData(i * 4);
        for (_k = 0, _len2 = facesData.length; _k < _len2; _k++) {
          datum = facesData[_k];
          triangleFacesData.push(datum);
        }
      }
      console.dir(triangleVertexData);
      console.dir(triangleFacesData);
      this.triangleVertex = this.GL.createBuffer();
      this.GL.bindBuffer(this.GL.ARRAY_BUFFER, this.triangleVertex);
      this.GL.bufferData(this.GL.ARRAY_BUFFER, new Float32Array(triangleVertexData), this.GL.STATIC_DRAW);
      this.triangleFaces = this.GL.createBuffer();
      this.GL.bindBuffer(this.GL.ELEMENT_ARRAY_BUFFER, this.triangleFaces);
      this.GL.bufferData(this.GL.ELEMENT_ARRAY_BUFFER, new Uint16Array(triangleFacesData), this.GL.STATIC_DRAW);
      return true;
    };

    _Class.prototype.init = function() {
      var e;
      try {
        this.initCanvas();
        this.initGLContext();
        this.initShaders();
        this.initTriangle();
        this.GL.clearColor(0.0, 0.0, 0.0, 0.0);
        return true;
      } catch (_error) {
        e = _error;
        console.error(e.stack);
        alert("You are not compatible :(");
        return false;
      }
    };

    _Class.prototype.draw = function() {
      this.GL.viewport(0.0, 0.0, this.canvas.width, this.canvas.height);
      this.GL.clear(this.GL.COLOR_BUFFER_BIT);
      this.GL.bindBuffer(this.GL.ARRAY_BUFFER, this.triangleVertex);
      this.GL.vertexAttribPointer(this._position, 2, this.GL.FLOAT, false, 4 * (2 + 3), 0);
      this.GL.vertexAttribPointer(this._color, 3, this.GL.FLOAT, false, 4 * (2 + 3), 2 * 4);
      this.GL.bindBuffer(this.GL.ELEMENT_ARRAY_BUFFER, this.triangleFaces);
      this.GL.drawElements(this.GL.TRIANGLES, this.hexagons.length * 4 * 3, this.GL.UNSIGNED_SHORT, 0);
      this.GL.flush();
      return window.requestAnimationFrame(this.draw);
    };

    _Class.prototype.run = function() {
      this.GL.useProgram(this.shaderProgram);
      return this.draw();
    };

    _Class.prototype.start = function() {
      return this.init() && this.run();
    };

    return _Class;

  })());

  window.addEventListener('DOMContentLoaded', APP.start, false);

}).call(this);
