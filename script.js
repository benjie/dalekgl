// Generated by CoffeeScript 1.7.1
var APP,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

APP = new ((function() {
  function _Class() {
    this.start = __bind(this.start, this);
    this.draw = __bind(this.draw, this);
  }

  _Class.prototype.VERTEX = 2;

  _Class.prototype.FRAGMENT = 3;

  _Class.prototype.vertexShaderSource = "attribute vec2 position;\nattribute vec3 color;\n\nvarying vec3 vColor;\nvoid main(void) {\n  gl_Position = vec4(position, 0., 1.);\n  vColor=color;\n}";

  _Class.prototype.fragmentShaderSource = "precision mediump float;\n\nvarying vec3 vColor;\nvoid main(void) {\n  gl_FragColor = vec4(vColor, 1.);\n}";

  _Class.prototype.getShader = function(type, source) {
    var shader;
    shader = this.GL.createShader(type);
    this.GL.shaderSource(shader, source);
    this.GL.compileShader(shader);
    if (!this.GL.getShaderParameter(shader, this.GL.COMPILE_STATUS)) {
      alert("ERROR IN " + (type === this.GL.VERTEX_SHADER ? 'vertex' : 'fragment') + " SHADER : " + (this.GL.getShaderInfoLog(shader)));
      return false;
    }
    return shader;
  };

  _Class.prototype.initCanvas = function() {
    var canvas;
    canvas = document.getElementById("canvas");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    this.canvas = canvas;
    return true;
  };

  _Class.prototype.initGLContext = function() {
    this.GL = this.canvas.getContext("experimental-webgl", {
      antialias: true
    });
    return true;
  };

  _Class.prototype.initShaders = function() {
    var fragmentShader, shaderProgram, vertexShader;
    vertexShader = this.getShader(this.GL.VERTEX_SHADER, this.vertexShaderSource);
    fragmentShader = this.getShader(this.GL.FRAGMENT_SHADER, this.fragmentShaderSource);
    shaderProgram = this.GL.createProgram();
    this.GL.attachShader(shaderProgram, vertexShader);
    this.GL.attachShader(shaderProgram, fragmentShader);
    this.GL.linkProgram(shaderProgram);
    this.shaderProgram = shaderProgram;
    this._color = this.GL.getAttribLocation(shaderProgram, "color");
    this._position = this.GL.getAttribLocation(shaderProgram, "position");
    this.GL.enableVertexAttribArray(this._color);
    this.GL.enableVertexAttribArray(this._position);
    return true;
  };

  _Class.prototype.initTriangle = function() {
    var triangleFacesData, triangleVertexData;
    triangleVertexData = [-1, -1, 0, 0, 1, 1, -1, 1, 1, 0, 1, 1, 1, 0, 0];
    this.triangleVertex = this.GL.createBuffer();
    this.GL.bindBuffer(this.GL.ARRAY_BUFFER, this.triangleVertex);
    this.GL.bufferData(this.GL.ARRAY_BUFFER, new Float32Array(triangleVertexData), this.GL.STATIC_DRAW);
    triangleFacesData = [0, 1, 2];
    this.triangleFaces = this.GL.createBuffer();
    this.GL.bindBuffer(this.GL.ELEMENT_ARRAY_BUFFER, this.triangleFaces);
    this.GL.bufferData(this.GL.ELEMENT_ARRAY_BUFFER, new Uint16Array(triangleFacesData), this.GL.STATIC_DRAW);
    return true;
  };

  _Class.prototype.init = function() {
    var e;
    try {
      this.initCanvas();
      this.initGLContext();
      this.initShaders();
      this.initTriangle();
      return this.GL.clearColor(0.0, 0.0, 0.0, 0.0);
    } catch (_error) {
      e = _error;
      console.error(e);
      alert("You are not compatible :(");
      return false;
    }
  };

  _Class.prototype.draw = function() {
    this.GL.viewport(0.0, 0.0, this.canvas.width, this.canvas.height);
    this.GL.clear(this.GL.COLOR_BUFFER_BIT);
    this.GL.bindBuffer(this.GL.ARRAY_BUFFER, this.triangleVertex);
    this.GL.vertexAttribPointer(this._position, 2, this.GL.FLOAT, false, 4 * (2 + 3), 0);
    this.GL.vertexAttribPointer(this._color, 3, this.GL.FLOAT, false, 4 * (2 + 3), 2 * 4);
    this.GL.bindBuffer(this.GL.ELEMENT_ARRAY_BUFFER, this.triangleFaces);
    this.GL.drawElements(this.GL.TRIANGLES, 3, this.GL.UNSIGNED_SHORT, 0);
    this.GL.flush();
    return window.requestAnimationFrame(this.draw);
  };

  _Class.prototype.run = function() {
    this.GL.useProgram(this.shaderProgram);
    return this.draw();
  };

  _Class.prototype.start = function() {
    this.init();
    return this.run();
  };

  return _Class;

})());

window.addEventListener('DOMContentLoaded', APP.start, false);
